# Enumify [![Build Status](https://secure.travis-ci.org/yonbergman/enumify.png)](http://travis-ci.org/yonbergman/enumify)

Enumify adds an enum command to all ActiveRecord models which enables you to work with string attributes as if they were enums

## Installing

Just add the enumify gem to your GemFile

```ruby
gem 'enumify'
```

## How to use

Just call the `enum` function in any ActiveRecord object, the function accepts the field name as the first variable and the possible values as an array

```ruby
class Event < ActiveRecord::Base
    enum :status, [:available, :canceled, :completed]
end
```

## Rails 4.1+

You can also instantiate a _Enumify_ enum by calling the `enumify` method instead of `enum`.  
This is especially helpful when your app is running Rail 4.1 or better which has it's own built in enum (although not as good)

```ruby
class Event < ActiveRecord::Base
    enumify :status, [:available, :canceled, :completed]
end
```
  
## Usage

After that you get several autogenerated commands to use with the enum

```ruby
# Access through field name

event.status                # returns the enum's current value as a symbol
event.status = :canceled    # sets the enum's value to canceled (can also get a string)


# Shorthand methods, access through the possible values

event.available?            # returns true if enum's current status is available
event.canceled!             # changes the enum's value to canceled

# Get all the possible values

Event::STATUSES             # returns all available status of the enum
```

## Options
#### :allow_nil
By default the enum field does not support a nil value. In order to allow nil values add the `allow_nil` option (similar to the Rails validation option).

```ruby
class Event < ActiveRecord::Base
    enum :status, [:available, :canceled, :completed], :allow_nil => true
end

Event.create! # Is valid and does not throw an exception.
```

#### :prefix
By default all enum values are available as scopes, bang and query methods based on the value. 
You can add a prefix for the enum values in order to differentiate different enums on the same object. 

```ruby
class Event < ActiveRecord::Base
    enum :status, [:available, :canceled, :completed], :prefix => true
    enum :subtype, [:company, :personal], :prefix => 'type'
end

event.available?            # Not available anymore
event.status_available?     # when prefix true
event.type_company?         # you can set a specific name for your prefix
```

#### :constant
By default, a constant is created on the class, containing the enum values.
You can remove the constant by passing a falsy value (i.e: `nil`, `false`) or rename it by passing a symbol or a string with a different name.

```ruby
class Event < ActiveRecord::Base
    enum :status, [:available, :canceled, :completed]
    enum :without_const, [:foo, :bar], :constant => false
    enum :custom_name, [:a, :b, :c], :constant => :special_name
end

event::STATUSES             # returns [:available, :canceled, :completed]
event::WITHOUT_CONST        # raises NameError
event::SPECIAL_NAME         # returns [:a, :b, :c]. Note the name was not pluralized.
event::CUSTOM_NAME          # raises NameError
```

## Callbacks
Another cool feature of enumify is the option to add a callback function that will be called each time the value of the field changes
This is cool to do stuff like log stuff or create behaviour on state changes

All you need to do is add a x_changed method in your class and the enumify will call it

```ruby
class Event < ActiveRecord::Base
    enum :status, [:available, :canceled, :completed]

    def status_changed(old, new)
        puts "status changed from #{old} to #{new}"
    end
end
```

## Scopes
One last thing that the enumify gem does is created scope (formerly nested_scopes) so you can easly query by the enum

For example if you want to count all the events that are canceled you can just run

```ruby
Event.canceled.count
```

In addition you can also use a negation scope to retrieve all the records that are not set to the given value.
For example to count all the events that are not canceled you can run

```ruby
Event.not_canceled.count
```

---

Copyright (c) 2011 Yonatan Bergman, released under the MIT license
